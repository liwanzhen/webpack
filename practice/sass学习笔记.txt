


1111.使用sass的!default标签可以实现这个目的。它很像css属性中!important标签的对立面，不同的是!default用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。（default用于定义一个默认值的同时，后面可以再修改它的值）


2222.sass允许@import命令写在css规则内。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。

有一个名为_blue-theme.scss的局部文件，内容如下：
aside {
  background: blue;
  color: white;
}

.blue-theme {@import "blue-theme"}

//生成的结果

.blue-theme {
  aside {
    background: blue;
    color: #fff;
  }
}

33333.include导入文件样式
@mixin dahao-radio {}    .error {@include dahao-radio;后面可以重写样式}

3333.sass兼容原生的css，所以它也支持原生的CSS@import（你可以把原始的css文件改名为.scss后缀，即可直接导入了。）

在sass中使用@import时，sass会尝试找到对应的sass文件并导入进来，但在下列三种情况下会生成原生的CSS@import，尽管这会造成浏览器解析css时的额外下载：

  被导入文件的名字以.css结尾；
  被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；
  被导入文件的名字是CSS的url()值。


4444.// 这种注释内容不会出现在生成的css文件中；  /* 这种注释内容会出现在生成的css文件中 */


5555.选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现

.seriousError {
  @extend .error;
  border-width: 3px;
}

6666.同层相邻组合选择器+选择header元素后紧跟的p元素;同层全体组合选择器~，选择所有跟在article后的同层article元素，不管它们之间隔了多少其他元素; 



















JQuery

事件：ready() focus blur change click dbclick 
方法：bind() hover() toggle() unbind() one() triggler() live()

1
（li:eq(2) 选择第3个li；
  li:contains('二货')  元素文本内容包含二货的元素  //二货必须加单引号
  li:has('p')
  :hidden过滤选择器的功能是获取全部不可见的元素,包括type属性值为hidden的元素
  :visible
  li[title='我是']    title属性值是’我是‘的所有li标签
  li[title!='我是']   title属性值不是’我是‘的所有li标签
  li[title*='果']     包含’果‘的所有title属性的所有li标签
）



2  使用:first过滤选择器可以获取指定父元素中的首个子元素，但该选择器返回的只有一个元素，并不是一个集合，而使用:first-child子元素过滤选择器则可以获取每个父元素中返回的首个子元素，它是一个集合，常用多个集合数据的选择处理。

3  first:是所有ul里面的li标签中的第一个，无论有多少个ul都只取第一个li
  first-child:是取ul的第一个子元素，是每一个ul中的第一个li


4  :input表单选择器可以实现，它的功能是返回全部的表单元素，不仅包括所有<input>标记的表单元素，而且还包括<textarea>、<select> 和 <button>标记的表单元素，因此，它选择的表单元素是最广的。

  #frmTest :input 注意冒号前面的空格

   :text表单文本选择器可以获取表单中全部单行的文本输入框元素


5  atrr适合设置元素的title或者alt属性；在设置元素的样式时，$().attr({style:"color:#f90;"})

6  html() 获取的是html内容 text() 获取的是文本内容   addClass();

   $().css("","").css("","")或者.css({"":"","":""})

   *给元素设置属性值的时候：不能通过attr（）或者css（）方法设置，而要通过类似于height（）这种方法设置


7  appendTo()是在元素的最后(比如div里面的最后一个元素)添加内容 
   $(selector).before(content)和$(selector).after(content)

   $("body").append($(".red").clone());  *内部的尾部
   
   $("body").prepend($(".red").clone());  *内部的头部
   
   $(selector).replaceWith(content)和$(content).replaceAll(selector)

   $(selector).wrap(wrapper)和$(selector).wrapInner(wrapper) 
   前者用于包裹元素本身，后者则用于包裹元素中的内容

   remove()方法删除所选元素本身和子元素，该方法可以通过添加过滤参数指定需要删除的某些元素，而empty()方法则只删除所选元素的子元素。

   replaceWith() 替换

* empty 只是清空元素中的内容
* removed 是清除整个节点  同detach



   删除 empty() detach() remove()


8
               $("#btntest").bind("click mouseout", function () {
                    $(this).attr("disabled", "true");
                })
              //  事件名之间用空格隔开

               $(selector).unbind(event,fun)

9
    hover()方法的功能是当鼠标移到所选元素上时，执行方法中的第一个函数，鼠标移出时，执行方法中的第二个函数，实现事件的切实效果
                $("div").hover(
                function () {
                    $(this).addClass("orange");
                },
                function () {
                    $(this).removeClass("orange")
                })

    toggle()方法可以在元素的click事件中绑定两个或两个以上的函数，同时，它还可以实现元素的隐藏与显示的切换，绑定多个函数的调用格式如下：

    $(selector).toggle(fun1(),fun2(),funN(),...)


10   focus事件在元素获取焦点时触发，如点击文本框时，触发该事件；而blur事件则在元素丢失焦点时触发，如点击除文本框的任何元素，都会触发该事件。
     .bind("focus",function(){}).bind("blur",function(){});

11
          $(function () {
                $("h4").bind("click", function () {
                    if ($("#hidval").val() == 0) {
                        $("ul").show(1000,function(){
                            $("#hidval").val(1);
                        })
                    } else {
                        $("ul").hide(1000,function(){
                            $("#hidval").val(0);
                        })
                    }
                })
            });

            $(function () {
                $("span").animate({
                    width: "80px",
                    height: "80px"
                },
                3000, function () {
                    $("#tip").html("执行完成!");
                });
            });

            $("span").stop();   // 停止动画
     
            $(selector).delay(duration)


12 Ajax
   
1   使用load()方法通过Ajax请求加载服务器中的数据，并把返回的数据放置到指定的元素中，它的调用格式为：

    load(url,[data],[callback])

参数url为加载服务器地址，可选项data参数为请求时发送的数据，callback参数为数据请求成功后，执行的回调函数。

        <script type="text/javascript">
            $(function () {
                $("#btnShow").bind("click", function () {
                    var $this = $(this);
                    $("ul")
                    .html("<img src='Images/Loading.gif' alt=''/>")
                    .load("http://www.imooc.com/data/fruit_part.html li",function(){
                        $this.attr("disabled", "true");
                    });
                })
            });
        </script>

2  使用getScript()方法异步请求并执行服务器中的JavaScript格式的文件，它的调用格式如下所示：

jQuery.getScript(url,[callback])或$.getScript(url,[callback])

参数url为服务器请求地址，可选项callback参数为请求成功后执行的回调函数。


3  使用getJSON()方法可以通过Ajax异步请求的方式，获取服务器中的数据，并对获取的数据进行解析，显示在页面中，它的调用格式为：

jQuery.getJSON(url,[data],[callback])或$.getJSON(url,[data],[callback])

其中，url参数为请求加载json格式文件的服务器地址，可选项data参数为请求时发送的数据，callback参数为数据请求成功后，执行的回调函数。


4  使用get()方法时，采用GET方式向服务器请求数据，并通过方法中回调函数的参数返回请求的数据，它的调用格式如下：

$.get(url,[callback])


5  与get()方法相比，post()方法多用于以POST方式向服务器发送数据，服务器接收到数据之后，进行处理，并将处理结果返回页面，调用格式如下：

$.post(url,[data],[callback])

参数url为服务器请求地址，可选项data为向服务器请求时发送的数据，可选项callback参数为请求成功后执行的回调函数。


6  使用serialize()方法可以将表单中有name属性的元素值进行序列化，生成标准URL编码文本字符串，直接可用于ajax请求，它的调用格式如下：

$(selector).serialize()

其中selector参数是一个或多个表单中的元素或表单元素本身。


7  使用ajax()方法是最底层、功能最强大的请求服务器数据的方法，它不仅可以获取服务器返回的数据，还能向服务器发送请求并传递数值，它的调用格式如下：

jQuery.ajax([settings])或$.ajax([settings])

其中参数settings为发送ajax请求时的配置对象，在该对象中，url表示服务器请求的路径，data为请求时传递的数据，dataType为服务器返回的数据类型，success为请求成功的执行的回调函数，type为发送数据请求的方式，默认为get。

            $(function () {
                $("#btnCheck").bind("click", function () {
                    $.ajax({
                        url: "http://www.imooc.com/data/check.php",
                        data: { num: $("#txtNumber").val() },
                        dataType: "text",
                        success: function (data) {
                            $("ul").append("<li>你输入的<b>  "
                            + $("#txtNumber").val() + " </b>是<b> "
                            + data + " </b></li>");
                        }
                    });
                })
            });


8  使用ajaxSetup()方法可以设置Ajax请求的一些全局性选项值，设置完成后，后面的Ajax请求将不需要再添加这些选项值，它的调用格式为：

jQuery.ajaxSetup([options])或$.ajaxSetup([options])

可选项options参数为一个对象，通过该对象设置Ajax请求时的全局选项值。


9  ajaxStart()和ajaxStop()方法是绑定Ajax事件。ajaxStart()方法用于在Ajax请求发出前触发函数，ajaxStop()方法用于在Ajax请求完成后触发函数。它们的调用格式为：

$(selector).ajaxStart(function())和$(selector).ajaxStop(function())

其中，两个方法中括号都是绑定的函数，当发送Ajax请求前执行ajaxStart()方法绑定的函数，请求成功后，执行ajaxStop ()方法绑定的函数。


$().parent();    //返回被选元素的直接父元素

$().parents();    //返回所有的祖先元素

$().parentsUntil();    //返回介于两个元素之间的父元素；

$().children();    //返回被选元素的所有直接子元素

$().find();    //返回限定区域的某元素

$().sibllings();    //返回被选元素的同胞元素

$().next();    //返回备选元素的下一个同胞元素

$().nextAll();   //

$().nestUtill();    //


$().first();

$().last();

$().eq();

$().filter(".center");    //返回含类名center的被选元素








9-4 放大镜插件    http://www.imooc.com/data/jquery.jqzoom.js


9-5 cookie插件――cookie

   使用cookie插件后，可以很方便地通过cookie对象保存、读取、删除用户的信息，还能通过cookie插件保存用户的浏览记录，它的调用格式为：

保存：$.cookie(key，value)；读取：$.cookie(key)，删除：$.cookie(key，null)

其中参数key为保存cookie对象的名称，value为名称对应的cookie值。


10-1 拖曳插件――draggable

     拖曳插件draggable的功能是拖动被绑定的元素，当这个jQuery UI插件与元素绑定后，可以通过调用draggable()方法，实现各种拖曳元素的效果，调用格式如下：

$(selector). draggable({options})

options参数为方法调用时的配置对象，根据该对象可以设置各种拖曳效果，如“containment”属性指定拖曳区域，“axis”属性设置拖曳时的坐标方向。


10-2 放置插件――droppable

     除使用draggable插件拖曳任意元素外，还可以调用droppable UI插件将拖曳后的任意元素放置在指定区域中，类似购物车效果，调用格式如下：

$(selector).droppable({options})

selector参数为接收拖曳元素，options为方法的配置对象，在对象中，drop函数表示当被接收的拖曳元素完全进入接收元素的容器时，触发该函数的调用。


10-3 拖曳排序插件――sortable

     拖曳排序插件的功能是将序列元素（例如<option>、<li>）按任意位置进行拖曳从而形成一个新的元素序列，实现拖曳排序的功能，它的调用格式为：

$(selector).sortable({options});

selector参数为进行拖曳排序的元素，options为调用方法时的配置对象，


10-4 面板折叠插件――accordion

     面板折叠插件可以实现页面中指定区域类似“手风琴”的折叠效果，即点击标题时展开内容，再点另一标题时，关闭已展开的内容，调用格式如下：

$(selector).accordion({options});

其中，参数selector为整个面板元素，options参数为方法对应的配置对象。


10-5 选项卡插件――tabs

     使用选项卡插件可以将<ul>中的<li>选项定义为选项标题，在标题中，再使用<a>元素的“href”属性设置选项标题对应的内容，它的调用格式如下：

$(selector).tabs({options});


10-7 菜单工具插件――menu
  
     菜单工具插件可以通过<ul>创建多级内联或弹出式菜单，支持通过键盘方向键控制菜单滑动，允许为菜单的各个选项添加图标，调用格式如下：

$(selector).menu({options});

selector参数为菜单列表中最外层<ul>元素，options为menu()方法的配置对象。


10-6 对话框插件――dialog

     对话框插件可以用动画的效果弹出多种类型的对话框，实现JavaScript代码中alert()和confirm()函数的功能，它的调用格式为：

$(selector).dialog({options});

selector参数为显示弹出对话框的元素，通常为<div>，options参数为方法的配置对象，在对象中可以设置对话框类型、“确定”、“取消”按钮执行的代码等。


10-8 微调按钮插件――spinner

     微调按钮插件不仅能在文本框中直接输入数值，还可以通过点击输入框右侧的上下按钮修改输入框的值，还支持键盘的上下方向键改变输入值，调用格式如下：

$(selector).spinner({options});

selector参数为文本输入框元素，可选项options参数为spinner()方法的配置对象，在该对象中，可以设置输入的最大、最小值，获取改变值和设置对应事件。

selector参数为选项卡整体外围元素，该元素包含选项卡标题与内容，options参数为tabs()方法的配置对象，通过该对象还能以ajax方式加载选项卡的内容。


10-9 工具提示插件――tooltip

     工具提示插件可以定制元素的提示外观，提示内容支持变量、Ajax远程获取，还可以自定义提示内容显示的位置，它的调用格式如下：

$(selector).tooltip({options});

其中selector为需要显示提示信息的元素，可选项参数options为tooltip()方法的配置对象，在该对象中，可以设置提示信息的弹出、隐藏时的效果和所在位置。


11-1 获取浏览器的名称与版本信息

     在jQuery中，通过$.browser对象可以获取浏览器的名称和版本信息，如$.browser.chrome为true，表示当前为Chrome浏览器，$.browser.mozilla为true，表示当前为火狐浏览器，还可以通过$.browser.version方式获取浏览器版本信息。
     

11-2 检测浏览器是否属于W3C盒子模型

浏览器的盒子模型分为两类，一类为标准的w3c盒子模型，另一类为IE盒子模型，两者区别为在Width和Height这两个属性值中是否包含padding和border的值，w3c盒子模型不包含，IE盒子模型则包含，而在jQuery 中，可以通过$.support.boxModel对象返回的值，检测浏览器是否属于标准的w3c盒子模型。


11-3 检测对象是否为空

在jQuery中，可以调用名为$.isEmptyObject的工具函数，检测一个对象的内容是否为空，如果为空，则该函数返回true，否则，返回false值，调用格式如下：

$.isEmptyObject(obj);

其中，参数obj表示需要检测的对象名称。


11-4 


11-5 检测两个节点的包含关系

调用名为$.contains的工具函数，能检测在一个DOM节点中是否包含另外一个DOM节点，如果包含，返回true，否则，返回false值，调用格式为：

$.contains (container, contained);

参数container表示一个DOM对象节点元素，用于包含其他节点的容器，contained是另一个DOM对象节点元素，用于被其他容器所包含。


11-6  字符串操作函数

调用名为$.trim的工具函数，能删除字符串中左右两边的空格符，但该函数不能删除字符串中间的空格，调用格式为：

$.trim (str);

参数str表示需要删除左右两边空格符的字符串。



11-7 URL操作函数

调用名为$. param的工具函数，能使对象或数组按照key/value格式进行序列化编码，该编码后的值常用于向服务端发送URL请求，调用格式为：

$. param (obj);

参数obj表示需要进行序列化的对象，该对象也可以是一个数组，整个函数返回一个经过序列化编码后的字符串。


11-8 使用$.extend()扩展工具函数

调用名为$. extend的工具函数，可以对原有的工具函数进行扩展，自定义类级别的jQuery插件，调用格式为：

$. extend ({options});

参数options表示自定义插件的函数内容。


11-9 使用$.extend()扩展Object对象

除使用$.extend扩展工具函数外，还可以扩展原有的Object对象，在扩展对象时，两个对象将进行合并，当存在相同属性名时，后者将覆盖前者，调用格式为：

$. extend (obj1,obj2,…objN);

参数obj1至objN表示需要合并的各个原有对象。


$("").keydown(function(e){
      $('').text(this.value)    //鼠标按下时显示按下的键的字母
});



事件

event.type：获取事件的类型
event.pageX  event.pageY  //获取鼠标当前相对于页面的坐标
event.preventDefault()    //阻止默认行为
event.stopPropagation()   //阻止事件冒泡


event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标

通过这2个属性，可以确定元素在当前页面的坐标值，鼠标相对于文档的左边缘的位置（左边）与 （顶边）的距离，简单来说是从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化

event.preventDefault() 方法：阻止默认行为

这个用的特别多，在执行这个方法后，如果点击一个链接（a标签），浏览器不会跳转到新的 URL 去了。我们可以用 event.isDefaultPrevented() 来确定这个方法是否(在那个事件对象上)被调用过了

event.stopPropagation() 方法：阻止事件冒泡

事件是可以冒泡的，为防止事件冒泡到DOM树上，也就是不触发的任何前辈元素上的事件处理函数

event.which：获取在鼠标单击时，单击的是鼠标的哪个键

event.which 将 event.keyCode 和 event.charCode 标准化了。event.which也将正常化的按钮按下(mousedown 和 mouseupevents)，左键报告1，中间键报告2，右键报告3

event.currentTarget : 在事件冒泡过程中的当前DOM元素

冒泡前的当前触发事件的DOM对象, 等同于this.

this和event.target的区别：

js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素；

.this和event.target都是dom对象

如果要使用jquey中的方法可以将他们转换，为jquery对象：$(this)和$(event.target);比如：event.target和$(event.target)的使用：




.val() .text() .html()

1..text()返回一个字符串，包含所有匹配元素的合并文本

2.input或textarea需要用.val(),scripts元素的值使用.html()方法



偏移量：offsetWidth offsetHeight offsetLeft offsetTop

可视区：clientHeight clientWidth （元素内容+内边距）

滚动大小：scrollWidth scrollHeight scrollLeft scrollTop





var head= document.getElementById("head");
head.style.cssText="width:20px;height:10px;display:bolck";



    通过$.Deferred处理过的代码，很明显没有了回调的嵌套，虽然代码量看起来多了点，但是实际上，每一个代码执行部分都被封装了起来，只留了Deferred的接口处理了，等于是我们把执行的流程控制交给了Deferred，这样的好处就是我们在写嵌套函数的时候，可以用deferred提供的管道风格编写同步代码了
    // jQuery的Deferred处理
    $('button:last').click(function() {

        function animate1() {
            var dtd = $.Deferred(); // 生成Deferred对象
            $("#block3").animate({
                width: "50%"
            }, 2000, function() {
                dtd.resolve(); // 改变Deferred对象的执行状态
            });
            return dtd;
        }

        function animate2() {
            var dtd = $.Deferred(); // 生成Deferred对象
            $("#block4").animate({
                width: "50%"
            }, 2000, function() {
                dtd.resolve(); // 改变Deferred对象的执行状态
            });
            return dtd;
        }

        var anim = animate1();

        anim.then(function() {
            return animate2();
        });

    });



















